<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="date" content=''>
    <title></title>
    <link rel="stylesheet" href="0_style.css">
  </head>
  <body>
    <div class="container-lg">
      <a href="/">Home</a>
    </div>
    <div class="content">
      <div class="container-lg">
        <article class="article markdown-body">
          <div class="article-inner">
            <h1 id="classes">Classes</h1>
            <ul>
            <li><p><a href="./cc_class_organisation_csharp.html">Class
            organization in C#</a></p></li>
            <li><p><a
            href="./cc_naming.html###Class-Names">Naming</a></p></li>
            <li><p>Encapsulation</p>
            <ul>
            <li>Keep variables and utility functions private. Use
            protected sometimes, for example to be able to unit-test
            it.</li>
            </ul></li>
            <li><p>Classes should be small.</p>
            <ul>
            <li>We measure classes by counting responsibilities</li>
            <li>Naming is probably the first way of helping determine
            class size. If we cannot derive a concise name for a class,
            then it’s likely too large. The more ambiguous the class
            name, the more likely it has too many responsibilities. For
            example, class names including weasel words like Processor
            or Manager or Super often hint at unfortunate aggregation of
            responsibilities.</li>
            <li>We should also be able to write a brief description of
            the class in about 25 words, without using the words “if,”
            “and,” “or,” or “but.”</li>
            <li>The Single Responsibility Principle (SRP) states that a
            class or module should have one, and only one, reason to
            change. This principle gives us both a definition of
            responsibility, and a guidelines for class size. Classes
            should have one responsibility—one reason to change.</li>
            <li>Trying to identify responsibilities (reasons to change)
            often helps us recognize and create better abstractions in
            our code</li>
            </ul></li>
            <li><p>Cohesion</p>
            <ul>
            <li>Strive to write classes with few instance variables and
            watch out for variables that are used by few methods.</li>
            <li>When classes lose cohesion, split them!</li>
            </ul></li>
            <li><p>Organizing for change</p>
            <ul>
            <li>In a clean system we organize our classes so as to
            reduce the risk of change.</li>
            <li>Open-Closed Principle (OCP): Classes should be open for
            extension but closed for modification.</li>
            <li>Dependency Inversion Principle (DIP): our classes should
            depend upon abstractions, not on concrete details.
            <ul>
            <li>Use <code>Dependency Injection</code>, depend on
            Interfaces and Abstractions rather than concrete
            implementations.</li>
            <li>Decoupling.</li>
            <li>Dependencies upon concrete details create challenges for
            testing our system.</li>
            </ul></li>
            </ul></li>
            </ul>
            <p>Best practices:</p>
            <ul>
            <li>Third party APIs. wrapping third-party APIs is a best
            practice. When you wrap a third-party API, you minimize your
            dependencies upon it: You can choose to move to a different
            library in the future without much penalty. Wrapping also
            makes it easier to mock out third-party calls when you are
            testing your own code.</li>
            </ul>
            <p>One final advantage of wrapping is that you aren’t tied
            to a particular vendor’s API design choices. You can define
            an API that you feel comfortable with. In the preceding
            example, we defined a single exception type for port device
            failure and found that we could write much cleaner code.</p>
            <p>Bibliography:</p>
            <ul>
            <li>Robert Martin - Clean Code - A Handbook of Agile
            Software Craftsmanship - 2008.</li>
            </ul>
          </div>
        </article>
        <p>Date: </p>
      </div>
    </div>
  </body>
</html>